
import z3

# Create symbolic buffer: a bit vector array where each element is of 4 bytes, because eventhough
# We are providing a string (29 chars), the calculation in the program are made on integers, so 4 bytes
buffer = [z3.BitVec(f'c_{i}', 32) for i in range(29)] 

solver = z3.Solver()

# We want only printable charactersolver 
for bitvec in buffer:
    solver.add(bitvec >= 0x20, bitvec <= 0x7e)

#check 1
solver.add(buffer[5] == 45 , buffer[11] == 45 , buffer[17] == 45 , buffer[23] == 45) 

#check 2
solver.add(                                                                                             
   buffer[1] - 48 <= 9,
   buffer[4] - 48 <= 9,
   buffer[6] - 48 <= 9,
   buffer[9] - 48 <= 9,
   buffer[15] - 48 <= 9,
   buffer[18] - 48 <= 9,
   buffer[22] - 48 <= 9,
   buffer[27] - 48 <= 9,
   buffer[28] - 48 <= 9
)

#check 3
solver.add( buffer[4] - 48 == 2 * (buffer[1] - 48) + 1, buffer[4] - 48 > 7, buffer[9] == buffer[4] - (buffer[1] - 48) + 2)

#check 4
solver.add( ( buffer[27] + buffer[28] ) % 13 == 8 ) 
    
#check 5
solver.add( ( buffer[27] + buffer[22] ) % 22 == 18)

#check 6
solver.add( ( buffer[18] + buffer[22] ) % 11 == 5 )

#check 7
solver.add( ( buffer[22] + buffer[28] + buffer[18]) % 26 == 4)

#check 8
solver.add( ( buffer[1] + buffer[4] * buffer[6]) % 41 == 5)

#check 9
solver.add( ( buffer[15] - buffer[28] ) % 4 == 1)

#check 10
solver.add( ( buffer[22] + buffer[4] ) % 4 == 3)

#check 11
solver.add(  buffer[20] == 66, buffer[21] == 66)

#check 12
solver.add( ( buffer[6] + buffer[15] * buffer[9] ) % 10 == 1 )

#check 13
solver.add( (buffer[15] + buffer[4] + buffer[27] - 18) % 16 == 8)

#check 14
solver.add( (buffer[28] - buffer[9] ) % 2 == 1 )

#check 15
solver.add( buffer[0] == 77)

check = solver.check()
print(check)

for i in range(29):
    print(chr(solver.model()[buffer[i]].as_long()), end="")
