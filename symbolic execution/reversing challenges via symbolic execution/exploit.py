#solving the same revmem challenge of the "reverse engineering" section with symbolic execution

#Let's import what we need 
import claripy
import angr

#let's create a project
proj = angr.Project("./revmem")

argv = ['./revmem']                                # argv[0] will be the path to the program
argv.append(claripy.BVS('arg1', 30*8))             # symbolic first argument, this will be argv[1]. Notice that we changed the size to
                                                   # 30*8 because our flag (see the main function above) is a string of 30 characters

state = proj.factory.entry_state(args=argv)        # here we are creating the entry state and the simulation manager
simgr = proj.factory.simulation_manager(state)

simgr.explore(find=0x400000+0x1236, avoid=0x400000+0x1244)        # explore...

if simgr.found:                                     # we execute until something is found
 found = simgr.found[0]
 print(found.solver.eval(argv[1]).to_bytes(30, 'big'))  